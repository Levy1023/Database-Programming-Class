DATABASE DESIGN AND IMPLEMENTATION ASSIGNMENT
Electronics Retail Company Database System

Student: Christopher Garcia
Course: Database Programming
Date: January 17, 2025

================================================================================
PART 1: DATABASE DESIGN
================================================================================

1. ENTITY IDENTIFICATION
================================================================================

This database system is designed to manage the core operations of an electronics 
retail company. The following entities have been identified to support inventory 
management, supplier relationships, and customer order processing:

ENTITY 1: Suppliers
-------------------
Description: Stores information about vendors who supply products to the company.
Attributes:
- Supplier_ID (Primary Key): Unique identifier for each supplier
- Supplier_Name: Legal business name of the supplier
- Phone: Contact phone number for the supplier
- Email: Email address for supplier communications

Business Purpose: Tracks supplier contact information for ordering, communication, 
and vendor management. Essential for maintaining supply chain relationships.

ENTITY 2: Categories
--------------------
Description: Organizes products into logical groupings for inventory management 
and customer browsing.
Attributes:
- Category_ID (Primary Key): Unique identifier for each category
- Category_Name: Descriptive name of the product category

Business Purpose: Enables product classification, simplifies inventory reporting, 
and improves product searchability for customers and staff.

ENTITY 3: Products
------------------
Description: Contains detailed information about all items available in inventory.
Attributes:
- Product_ID (Primary Key): Unique identifier for each product
- Product_Name: Descriptive name of the product
- Category_ID (Foreign Key): References Categories table
- Supplier_ID (Foreign Key): References Suppliers table
- Unit_Price: Retail price per unit
- QOH (Quantity on Hand): Current inventory level

Business Purpose: Central repository for all product information. Links products 
to their categories and suppliers while tracking pricing and inventory levels.

ENTITY 4: Customers
-------------------
Description: Stores customer information for order processing and relationship 
management.
Attributes:
- Customer_ID (Primary Key): Unique identifier for each customer
- Customer_Name: Full name of the customer
- Email: Customer email address
- Phone: Customer contact number

Business Purpose: Maintains customer records for order fulfillment, communication, 
and future marketing initiatives.

ENTITY 5: Orders
----------------
Description: Records all customer purchase transactions.
Attributes:
- Order_ID (Primary Key): Unique identifier for each order
- Customer_ID (Foreign Key): References Customers table
- Order_Date: Date the order was placed
- Order_Time: Time the order was placed
- Order_Amount: Total monetary value of the order

Business Purpose: Tracks sales transactions, links customers to their purchases, 
and maintains historical sales data for analysis.

ENTITY 6: Order_Details
-----------------------
Description: Contains line items for each order, linking products to orders.
Attributes:
- Order_Detail_ID (Primary Key): Unique identifier for each order line item
- Order_ID (Foreign Key): References Orders table
- Product_ID (Foreign Key): References Products table
- Quantity: Number of units ordered
- Line_Total: Total price for this line item (Quantity Ã— Unit Price)

Business Purpose: Implements a many-to-many relationship between Orders and 
Products, allowing multiple products per order and tracking quantity/pricing 
for each item.


2. ENTITY RELATIONSHIP DIAGRAM (ERD)
================================================================================

The following ERD represents the complete database structure with all entities, 
attributes, relationships, and constraints:

ERD Code (for dbdiagram.io):
-----------------------------

Table Suppliers {
  Supplier_ID INT [pk, increment]
  Supplier_Name VARCHAR(100) [not null]
  Phone VARCHAR(20)
  Email VARCHAR(100) [unique]
  
  Note: 'Stores supplier/vendor information'
}

Table Categories {
  Category_ID INT [pk, increment]
  Category_Name VARCHAR(50) [not null, unique]
  
  Note: 'Product category classifications'
}

Table Products {
  Product_ID INT [pk, increment]
  Product_Name VARCHAR(100) [not null]
  Category_ID INT [ref: > Categories.Category_ID]
  Supplier_ID INT [ref: > Suppliers.Supplier_ID]
  Unit_Price DECIMAL(10,2) [not null]
  QOH INT [default: 0]
  
  Note: 'Product inventory with pricing and stock levels'
}

Table Customers {
  Customer_ID INT [pk, increment]
  Customer_Name VARCHAR(100) [not null]
  Email VARCHAR(100) [unique]
  Phone VARCHAR(20)
  
  Note: 'Customer information for order processing'
}

Table Orders {
  Order_ID INT [pk, increment]
  Customer_ID INT [ref: > Customers.Customer_ID]
  Order_Date DATE [not null]
  Order_Time TIME [not null]
  Order_Amount DECIMAL(10,2) [not null]
  
  Note: 'Customer order headers'
}

Table Order_Details {
  Order_Detail_ID INT [pk, increment]
  Order_ID INT [ref: > Orders.Order_ID]
  Product_ID INT [ref: > Products.Product_ID]
  Quantity INT [not null]
  Line_Total DECIMAL(10,2) [not null]
  
  Note: 'Order line items linking products to orders'
}

RELATIONSHIP DESCRIPTIONS:
--------------------------

1. Suppliers to Products (One-to-Many)
   - One supplier can supply multiple products
   - Each product has exactly one primary supplier
   - Cardinality: 1:N
   - Foreign Key: Products.Supplier_ID references Suppliers.Supplier_ID

2. Categories to Products (One-to-Many)
   - One category contains multiple products
   - Each product belongs to exactly one category
   - Cardinality: 1:N
   - Foreign Key: Products.Category_ID references Categories.Category_ID

3. Customers to Orders (One-to-Many)
   - One customer can place multiple orders
   - Each order is placed by exactly one customer
   - Cardinality: 1:N
   - Foreign Key: Orders.Customer_ID references Customers.Customer_ID

4. Orders to Order_Details (One-to-Many)
   - One order can have multiple line items
   - Each line item belongs to exactly one order
   - Cardinality: 1:N
   - Foreign Key: Order_Details.Order_ID references Orders.Order_ID

5. Products to Order_Details (One-to-Many)
   - One product can appear in multiple order line items
   - Each line item references exactly one product
   - Cardinality: 1:N
   - Foreign Key: Order_Details.Product_ID references Products.Product_ID

DATA TYPE SPECIFICATIONS:
-------------------------

INT: Used for all ID fields (primary and foreign keys) to ensure efficient 
     indexing and joins. Auto-increment ensures unique values.

VARCHAR: Used for text fields with specified maximum lengths based on expected 
         data (names, contact information). Provides flexibility while controlling 
         storage.

DECIMAL(10,2): Used for monetary values (prices, amounts) with precision of 10 
               digits and 2 decimal places for cents. Ensures accurate financial 
               calculations.

DATE: Stores order dates in YYYY-MM-DD format for temporal analysis and reporting.

TIME: Stores order times in HH:MM:SS format for detailed transaction tracking.


3. NORMALIZATION VS DENORMALIZATION
================================================================================

NORMALIZATION ANALYSIS:

The database design for the electronics retail company adheres to the principles 
of database normalization through the Third Normal Form (3NF), ensuring data 
integrity, reducing redundancy, and optimizing query performance. This analysis 
demonstrates how the design satisfies each normalization level.

First Normal Form (1NF) Compliance:
The database satisfies 1NF requirements as all tables contain only atomic values 
with no repeating groups or arrays. Each column in every table stores a single 
value rather than multiple values or lists. For example, in the Products table, 
each product has a single Product_Name, Unit_Price, and QOH value rather than 
storing multiple prices or names in one field. The Orders table stores one order 
per row with a single Order_Date, Order_Time, and Order_Amount. The separation 
of Order_Details from Orders prevents storing multiple products within a single 
order record, instead creating individual rows for each product in an order. 
Every table has a clearly defined primary key that uniquely identifies each row, 
ensuring that no duplicate rows exist and that each record can be distinctly 
referenced. This atomic structure enables efficient querying and prevents data 
anomalies that occur when multiple values are packed into single fields.

Second Normal Form (2NF) Compliance:
The design achieves 2NF by eliminating partial dependencies, where non-key 
attributes depend on only part of a composite primary key. Since all tables use 
single-column primary keys rather than composite keys, partial dependencies 
cannot exist by definition. Each non-key attribute in every table depends on 
the complete primary key. In the Products table, attributes like Product_Name, 
Unit_Price, and QOH all depend entirely on Product_ID, not on any subset of 
attributes. The Order_Details table, which could have used a composite key of 
Order_ID and Product_ID, instead uses a surrogate primary key Order_Detail_ID. 
This design choice eliminates potential partial dependencies while maintaining 
referential integrity through foreign keys. All descriptive attributes are 
functionally dependent on their respective table's primary key, ensuring that 
each piece of information is stored in association with its proper identifier.

Third Normal Form (3NF) Compliance:
The database satisfies 3NF by removing transitive dependencies, where non-key 
attributes depend on other non-key attributes. Each table contains only attributes 
that directly depend on the primary key, with related but independent data stored 
in separate tables. For instance, supplier information (Supplier_Name, Phone, 
Email) is stored in the Suppliers table rather than being duplicated in the 
Products table. Products reference suppliers through Supplier_ID foreign key, 
eliminating the transitive dependency where Product_Name might indirectly determine 
Supplier_Name. Similarly, category information is separated into the Categories 
table, preventing the transitive dependency where Product_ID would determine 
Category_Name through Category_ID. Customer details are stored once in the 
Customers table rather than being repeated in each order record. This separation 
ensures that updating a supplier's phone number or a category's name requires 
modifying only one record, preventing update anomalies and maintaining data 
consistency across the entire database.

Denormalization Considerations:
While the current design maintains strict normalization, certain scenarios might 
justify selective denormalization to improve query performance. For example, 
storing Order_Amount in the Orders table represents a calculated denormalization, 
as this value could be derived by summing Line_Total values from Order_Details. 
However, this denormalization improves performance by eliminating the need to join 
and aggregate Order_Details for every query requesting order totals. Similarly, 
storing Line_Total in Order_Details, which equals Quantity multiplied by Unit_Price, 
provides faster access to line item totals without requiring repeated calculations. 
In a high-transaction environment, further denormalization might include adding 
Category_Name to the Products table to avoid joins when displaying product lists, 
or caching Supplier_Name with products for faster inventory reports. However, these 
denormalizations create update anomalies where changes to category or supplier 
names must be propagated to multiple tables. The current design strikes a balance 
between normalization benefits (data integrity, reduced redundancy, easier 
maintenance) and practical performance needs (strategic calculated fields), making 
it suitable for a growing electronics retail operation where data consistency is 
critical but query performance remains important for customer experience and 
operational efficiency.


================================================================================
PART 2: SQL IMPLEMENTATION
================================================================================

1. CREATE TABLES USING DDL
================================================================================

The following SQL Data Definition Language (DDL) statements create the complete 
database structure with appropriate constraints and relationships:

-- ============================================================================
-- DROP EXISTING TABLES (for clean implementation)
-- ============================================================================

DROP TABLE IF EXISTS Order_Details;
DROP TABLE IF EXISTS Orders;
DROP TABLE IF EXISTS Customers;
DROP TABLE IF EXISTS Products;
DROP TABLE IF EXISTS Categories;
DROP TABLE IF EXISTS Suppliers;

-- ============================================================================
-- CREATE SUPPLIERS TABLE
-- ============================================================================

CREATE TABLE Suppliers (
    Supplier_ID INT AUTO_INCREMENT PRIMARY KEY,
    Supplier_Name VARCHAR(100) NOT NULL,
    Phone VARCHAR(20),
    Email VARCHAR(100) UNIQUE,
    CONSTRAINT chk_supplier_email CHECK (Email LIKE '%@%')
);

-- ============================================================================
-- CREATE CATEGORIES TABLE
-- ============================================================================

CREATE TABLE Categories (
    Category_ID INT AUTO_INCREMENT PRIMARY KEY,
    Category_Name VARCHAR(50) NOT NULL UNIQUE
);

-- ============================================================================
-- CREATE PRODUCTS TABLE
-- ============================================================================

CREATE TABLE Products (
    Product_ID INT AUTO_INCREMENT PRIMARY KEY,
    Product_Name VARCHAR(100) NOT NULL,
    Category_ID INT NOT NULL,
    Supplier_ID INT NOT NULL,
    Unit_Price DECIMAL(10,2) NOT NULL,
    QOH INT DEFAULT 0,
    CONSTRAINT fk_product_category FOREIGN KEY (Category_ID) 
        REFERENCES Categories(Category_ID)
        ON DELETE RESTRICT
        ON UPDATE CASCADE,
    CONSTRAINT fk_product_supplier FOREIGN KEY (Supplier_ID) 
        REFERENCES Suppliers(Supplier_ID)
        ON DELETE RESTRICT
        ON UPDATE CASCADE,
    CONSTRAINT chk_unit_price CHECK (Unit_Price > 0),
    CONSTRAINT chk_qoh CHECK (QOH >= 0)
);

-- ============================================================================
-- CREATE CUSTOMERS TABLE
-- ============================================================================

CREATE TABLE Customers (
    Customer_ID INT AUTO_INCREMENT PRIMARY KEY,
    Customer_Name VARCHAR(100) NOT NULL,
    Email VARCHAR(100) UNIQUE,
    Phone VARCHAR(20),
    CONSTRAINT chk_customer_email CHECK (Email LIKE '%@%')
);

-- ============================================================================
-- CREATE ORDERS TABLE
-- ============================================================================

CREATE TABLE Orders (
    Order_ID INT AUTO_INCREMENT PRIMARY KEY,
    Customer_ID INT NOT NULL,
    Order_Date DATE NOT NULL,
    Order_Time TIME NOT NULL,
    Order_Amount DECIMAL(10,2) NOT NULL,
    CONSTRAINT fk_order_customer FOREIGN KEY (Customer_ID) 
        REFERENCES Customers(Customer_ID)
        ON DELETE RESTRICT
        ON UPDATE CASCADE,
    CONSTRAINT chk_order_amount CHECK (Order_Amount >= 0)
);

-- ============================================================================
-- CREATE ORDER_DETAILS TABLE
-- ============================================================================

CREATE TABLE Order_Details (
    Order_Detail_ID INT AUTO_INCREMENT PRIMARY KEY,
    Order_ID INT NOT NULL,
    Product_ID INT NOT NULL,
    Quantity INT NOT NULL,
    Line_Total DECIMAL(10,2) NOT NULL,
    CONSTRAINT fk_orderdetail_order FOREIGN KEY (Order_ID) 
        REFERENCES Orders(Order_ID)
        ON DELETE CASCADE
        ON UPDATE CASCADE,
    CONSTRAINT fk_orderdetail_product FOREIGN KEY (Product_ID) 
        REFERENCES Products(Product_ID)
        ON DELETE RESTRICT
        ON UPDATE CASCADE,
    CONSTRAINT chk_quantity CHECK (Quantity > 0),
    CONSTRAINT chk_line_total CHECK (Line_Total >= 0)
);

-- ============================================================================
-- CREATE INDEXES FOR PERFORMANCE
-- ============================================================================

CREATE INDEX idx_products_category ON Products(Category_ID);
CREATE INDEX idx_products_supplier ON Products(Supplier_ID);
CREATE INDEX idx_orders_customer ON Orders(Customer_ID);
CREATE INDEX idx_orders_date ON Orders(Order_Date);
CREATE INDEX idx_orderdetails_order ON Order_Details(Order_ID);
CREATE INDEX idx_orderdetails_product ON Order_Details(Product_ID);


2. POPULATE TABLES USING DML
================================================================================

The following SQL Data Manipulation Language (DML) statements populate the 
database with sample data and demonstrate INSERT, UPDATE, and DELETE operations:

-- ============================================================================
-- INSERT DATA INTO SUPPLIERS TABLE
-- ============================================================================

INSERT INTO Suppliers (Supplier_Name, Phone, Email) VALUES
('TechWare Solutions', '555-0101', 'contact@techware.com'),
('Global Electronics Inc', '555-0102', 'sales@globalelectronics.com'),
('Digital Depot', '555-0103', 'orders@digitaldepot.com'),
('SmartGadgets LLC', '555-0104', 'info@smartgadgets.com'),
('CompTech Distributors', '555-0105', 'support@comptech.com'),
('ElectroWorld Wholesale', '555-0106', 'wholesale@electroworld.com'),
('Prime Components', '555-0107', 'sales@primecomponents.com');

-- ============================================================================
-- INSERT DATA INTO CATEGORIES TABLE
-- ============================================================================

INSERT INTO Categories (Category_Name) VALUES
('Laptops'),
('Smartphones'),
('Tablets'),
('Accessories'),
('Audio'),
('Gaming'),
('Networking');

-- ============================================================================
-- INSERT DATA INTO PRODUCTS TABLE
-- ============================================================================

INSERT INTO Products (Product_Name, Category_ID, Supplier_ID, Unit_Price, QOH) VALUES
('Dell XPS 15 Laptop', 1, 1, 1299.99, 15),
('MacBook Pro 14-inch', 1, 1, 1999.99, 8),
('HP Pavilion Laptop', 1, 2, 799.99, 25),
('Lenovo ThinkPad X1', 1, 5, 1449.99, 12),
('ASUS ROG Gaming Laptop', 1, 7, 1899.99, 6),
('iPhone 15 Pro', 2, 3, 999.99, 30),
('Samsung Galaxy S24', 2, 3, 899.99, 35),
('Google Pixel 8', 2, 4, 699.99, 20),
('OnePlus 12', 2, 4, 799.99, 18),
('Motorola Edge 40', 2, 6, 599.99, 22),
('iPad Pro 12.9-inch', 3, 3, 1099.99, 14),
('Samsung Galaxy Tab S9', 3, 3, 849.99, 16),
('Microsoft Surface Pro 9', 3, 2, 1299.99, 10),
('Amazon Fire HD 10', 3, 6, 149.99, 40),
('Lenovo Tab P11 Pro', 3, 5, 499.99, 25),
('AirPods Pro', 4, 3, 249.99, 50),
('Samsung Galaxy Buds', 4, 3, 149.99, 45),
('USB-C Hub Adapter', 4, 7, 39.99, 100),
('Wireless Mouse', 4, 5, 29.99, 80),
('Laptop Backpack', 4, 6, 49.99, 60),
('Sony WH-1000XM5 Headphones', 5, 4, 399.99, 20),
('Bose QuietComfort 45', 5, 4, 329.99, 18),
('JBL Flip 6 Speaker', 5, 6, 129.99, 35),
('Beats Studio Buds', 5, 3, 149.99, 28),
('Soundbar 5.1 System', 5, 2, 299.99, 12),
('PlayStation 5 Console', 6, 1, 499.99, 5),
('Xbox Series X', 6, 1, 499.99, 7),
('Nintendo Switch OLED', 6, 4, 349.99, 15),
('Gaming Headset RGB', 6, 7, 89.99, 40),
('Mechanical Gaming Keyboard', 6, 7, 129.99, 30),
('TP-Link WiFi 6 Router', 7, 5, 89.99, 25),
('Netgear Mesh System', 7, 5, 299.99, 12),
('Ethernet Switch 8-Port', 7, 7, 39.99, 35),
('WiFi Range Extender', 7, 5, 49.99, 40),
('Cat6 Ethernet Cables 10ft', 7, 7, 14.99, 100);

-- ============================================================================
-- INSERT DATA INTO CUSTOMERS TABLE
-- ============================================================================

INSERT INTO Customers (Customer_Name, Email, Phone) VALUES
('John Smith', 'john.smith@email.com', '555-1001'),
('Sarah Johnson', 'sarah.j@email.com', '555-1002'),
('Michael Williams', 'mwilliams@email.com', '555-1003'),
('Emily Brown', 'ebrown@email.com', '555-1004'),
('David Jones', 'djones@email.com', '555-1005'),
('Jessica Davis', 'jdavis@email.com', '555-1006'),
('Christopher Miller', 'cmiller@email.com', '555-1007'),
('Amanda Wilson', 'awilson@email.com', '555-1008');

-- ============================================================================
-- INSERT DATA INTO ORDERS TABLE
-- ============================================================================

INSERT INTO Orders (Customer_ID, Order_Date, Order_Time, Order_Amount) VALUES
(1, '2025-01-10', '10:30:00', 1549.98),
(2, '2025-01-11', '14:15:00', 999.99),
(3, '2025-01-11', '16:45:00', 2099.98),
(4, '2025-01-12', '09:20:00', 399.99),
(5, '2025-01-12', '11:00:00', 1449.99),
(6, '2025-01-13', '13:30:00', 679.97),
(1, '2025-01-14', '15:45:00', 249.99),
(7, '2025-01-15', '10:00:00', 3299.97);

-- ============================================================================
-- INSERT DATA INTO ORDER_DETAILS TABLE
-- ============================================================================

INSERT INTO Order_Details (Order_ID, Product_ID, Quantity, Line_Total) VALUES
-- Order 1: John Smith
(1, 1, 1, 1299.99),
(1, 18, 1, 39.99),
(1, 19, 1, 29.99),
(1, 31, 2, 179.98),
-- Order 2: Sarah Johnson
(2, 6, 1, 999.99),
-- Order 3: Michael Williams
(3, 2, 1, 1999.99),
(3, 18, 1, 39.99),
(3, 20, 1, 49.99),
-- Order 4: Emily Brown
(4, 21, 1, 399.99),
-- Order 5: David Jones
(5, 4, 1, 1449.99),
-- Order 6: Jessica Davis
(6, 8, 1, 699.99),
(6, 16, 1, 249.99),
(6, 35, 2, 29.98),
-- Order 7: John Smith (second order)
(7, 16, 1, 249.99),
-- Order 8: Christopher Miller
(8, 26, 1, 499.99),
(8, 27, 1, 499.99),
(8, 1, 1, 1299.99),
(8, 29, 1, 89.99),
(8, 30, 1, 129.99),
(8, 31, 2, 179.98),
(8, 33, 1, 39.99),
(8, 35, 4, 59.96);

-- ============================================================================
-- UPDATE STATEMENTS
-- ============================================================================

-- Update 1: Increase price of all gaming accessories by 10%
UPDATE Products 
SET Unit_Price = Unit_Price * 1.10 
WHERE Category_ID = 6;

-- Update 2: Change supplier phone number
UPDATE Suppliers 
SET Phone = '555-0199' 
WHERE Supplier_Name = 'TechWare Solutions';

-- Update 3: Update customer email address
UPDATE Customers 
SET Email = 'john.smith.new@email.com' 
WHERE Customer_ID = 1;

-- Update 4: Decrease quantity on hand after sale
UPDATE Products 
SET QOH = QOH - 1 
WHERE Product_ID = 6;

-- Update 5: Correct a product name typo
UPDATE Products 
SET Product_Name = 'Dell XPS 15 Laptop (Corrected)' 
WHERE Product_ID = 1;

-- ============================================================================
-- DELETE STATEMENTS
-- ============================================================================

-- Delete 1: Remove a discontinued product (must not be in any orders)
DELETE FROM Products 
WHERE Product_ID = 35 AND Product_ID NOT IN (
    SELECT DISTINCT Product_ID FROM Order_Details
);

-- Delete 2: Remove a test customer with no orders
DELETE FROM Customers 
WHERE Customer_ID = 8 AND Customer_ID NOT IN (
    SELECT DISTINCT Customer_ID FROM Orders
);

-- Delete 3: Remove old supplier that no longer supplies products
DELETE FROM Suppliers 
WHERE Supplier_ID = 6 AND Supplier_ID NOT IN (
    SELECT DISTINCT Supplier_ID FROM Products
);

-- Delete 4: Remove a category with no products
DELETE FROM Categories 
WHERE Category_ID = 7 AND Category_ID NOT IN (
    SELECT DISTINCT Category_ID FROM Products
);

-- Delete 5: Remove test order details for a specific order
DELETE FROM Order_Details 
WHERE Order_ID = 8 AND Product_ID = 35;


================================================================================
END OF ASSIGNMENT
================================================================================

SUMMARY:

This database design and implementation provides a robust foundation for the 
electronics retail company's inventory and order management system. The design 
adheres to normalization principles through 3NF while incorporating strategic 
denormalization for performance. All entities are properly related through 
foreign keys with appropriate constraints to maintain referential integrity.

The SQL implementation includes:
- 6 normalized tables with proper constraints
- 35+ product records across 7 categories
- 7 supplier records
- 8 customer records
- 8 orders with 20+ order detail line items
- 5 UPDATE statements demonstrating data modification
- 5 DELETE statements with safety checks
- Indexes for optimized query performance

The system is ready for deployment and can scale to accommodate the company's 
growth while maintaining data integrity and query efficiency.
